# 02_总体架构与模块划分

## 2.1 分层架构的设计哲学与演进
EasyStay 平台在底层设计上深度践行了关注点分离（SOC）原则。后端服务集群并没有采取臃肿的巨石架构，而是基于 Node.js 生态构建了一套层级分明、低耦合的内部生态位。最外层是基于 Nginx 的流量调度层，作为整个系统的咽喉，它不仅负责 SSL 卸载与静态资源加速，更通过反向代理规则将复杂的 URL 空间精确投射到内部不同的服务模块上。这种设计确保了系统在面对突发流量时，可以通过横向扩展后端节点而无需修改前端契约。

后端内部则通过 Express 框架实现了经典的“路由-控制器-服务-模型”四层体系。路由层（Routes）充当了契约定义的角色，严格规定了每一个 API 端点的语义与准入条件。控制器层（Controllers）作为逻辑中枢，负责对 HTTP 上下文进行拆解，并协调不同的 Service 模块完成复杂的跨模块任务。服务层（Services）则封装了具体的业务算法，如 AI 的 Prompt 编排与 LBS 坐标转换，确保了业务逻辑能够脱离 HTTP 环境进行独立单元测试。最深处的模型层（Models）则利用 Sequelize ORM 实现了对物理存储的抽象，将数据库操作转化为直观的对象生命周期管理。

## 2.2 前端三端的异构与统一
在前端架构的构建上，我们面对的是典型的多场景协同需求。管理后台（admin-web）作为生产力工具，其核心挑战在于处理超长生命周期的页面状态与极高的数据交互密度。我们选择了 React 18 配合单向数据流模式，通过 Context API 管理全局鉴权与用户信息，通过精细的 Axios 拦截器实现了请求链路的自动加签。这种架构赋予了后台极强的表单嵌套处理能力，能够轻松应对酒店录入这种涉及多维度 JSON 数据的场景。

移动端（mobile-app）则面向终端用户，其宿主环境的不确定性要求架构必须具备跨平台兼容能力。Taro 在此扮演了关键角色，它不仅统一了开发范式，更通过编译时优化解决了不同平台（小程序与 H5）之间的性能损耗。移动端的架构侧重于“视图-逻辑”的解耦，通过自定义 Hook 封装了位置感知与搜索防抖逻辑。尽管移动端与管理后台在技术栈上有所差异，但它们在数据访问层（Utils/Request）保持了高度统一，均遵循 Bearer Token 规范并实现了标准化的 Restful 响应拦截。

## 2.3 关键数据流向与中间件机制
系统的数据生命周期是一个由中间件（Middleware）强力管控的闭环。每一笔进入后端的请求都会先经过安全过滤层。JWT 校验中间件负责在亚毫秒级别提取 Header 中的签名标识，并利用非对称加密（或预设 Secret）验证用户合法性。通过验证后，用户信息被注入到上下文对象中，此时角色鉴权中间件（RBAC）介入，根据预定义的白名单权限矩阵，判断该用户是否有权访问审计或库存等核心资源。这种流水线式的处理逻辑，使得控制器可以专注于纯粹的业务推导，极大地提升了代码的可读性。

在涉及第三方集成的场景下，数据流展现出了极高的工程技巧。例如在一个典型的 AI 推荐请求中，流向路径并非简单的 A 到 B。后端首先发起 LBS 城市定位请求获取坐标锚点，随后进入事务层查询 MySQL 中的实时库存与价格，获取基础数据集。接着，这组数据集连同历史上下文被投喂给 GLM 语义引擎。在大模型完成润色后，结果经由助手 Service 的数据清洗，最终转化为前端可直接渲染的 UI 视图。这种多源异构数据的聚合能力，是 EasyStay 架构核心竞争力的体现。

## 2.4 物理模块分布与工程化目录
整个工程的物理结构高度对齐了其逻辑架构。根目录下的 `server` 文件夹代表了系统的灵魂，其中 `src` 子目录按照功能语义进行了严格划分。路由、控制器、中间件、模型和服务的扁平化组织，使得新功能的接入仅需按照相应规范在不同层级进行增量扩展。`admin-web` 与 `mobile-app` 作为独立工程，各自拥有完善的构建脚本与静态资源管理策略。

部署模块作为架构的最后一块拼图，其在物理位置上位于 `deploy` 和项目的根目录。`docker-compose.yml` 精确定义了数据库容器的网络拓扑与存储卷挂载，而 `nginx.conf` 则配置了全站的路由镜像关系。这种清晰的物理目录划分，不仅方便了开发者的代码检索，更为基于 Git 的版本管理与流水线自动部署提供了极佳的基础，确保了平台在从开发到上线的全生命周期中始终保持有序。
